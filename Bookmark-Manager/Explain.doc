1) Helper to make IDs
function generateBookId() {
  return Math.floor(1000 + Math.random() * 9000);
}


Creates a random 4-digit number (1000–9999).

Note: You don’t actually use this function below—you’re using Date.now() instead. Either remove this function, or use it when creating the bookmark (id: generateBookId()).

2) Grab DOM elements & set up state
const form = document.getElementById("bookmark-form");
let bookmarks = [];
const bookmarksList = document.getElementById('bookmarksList');


form points to your <form id="bookmark-form">.

bookmarks is an in-memory array to store all bookmarks.

bookmarksList is the container where each bookmark card will be rendered.

3) Handle form submission
form.addEventListener("submit", (e) => {
  e.preventDefault(); // stop page refresh
  const title = document.getElementById('websiteTitle').value;
  const url = document.getElementById('websiteUrl').value;
  const category = document.getElementById('category').value;

  const bookmark = {
    id: Date.now(),      // unique-ish ID from timestamp
    title: title,
    url: url,
    category: category
  };

  bookmarks.push(bookmark);  // add to array
  console.log(bookmarks);    // for debugging
  renderBookmarks();         // update UI
});


Prevents the default form submit (page reload).

Reads the three input values.

Builds a bookmark object with an id, title, url, and category.

Pushes it into the bookmarks array.

Calls renderBookmarks() to refresh the display.

4) Render the bookmarks list
function renderBookmarks() {
  bookmarksList.innerHTML = ''; // clear old UI

  if (bookmarks.length === 0) {
    bookmarksList.innerHTML = `No Bookmark Found`;
  } else {
    bookmarks.forEach((b) => {
      const bookmarkItem = document.createElement('div');
      bookmarkItem.classList.add('bookmark-item');

      bookmarkItem.innerHTML = `
        <div class="bookmark-info">
          <h3>${b.title}</h3>
          <a href="${b.url}" class="bookmark-link" target="_blank">${b.url}</a>
          <div class="bookmark-category">${b.category}</div>
        </div>
        <button class="delete-btn">Delete</button>
      `;

      bookmarksList.append(bookmarkItem);

      const deletebtn = bookmarkItem.querySelector('.delete-btn');
      deletebtn.addEventListener('click', () => {
        handleDelete(b.id);
      });
    });
  }
}


Wipes the list each time (so you get a clean re-render).

If no bookmarks exist, shows “No Bookmark Found”.

Otherwise, for each bookmark:

Creates a .bookmark-item card.

Fills it with the title, clickable URL (opens in a new tab), category, and a Delete button.

Appends the card to the list.

Wires the Delete button to call handleDelete with the matching id.

5) Delete by ID, then re-render
function handleDelete(id) {
  bookmarks = bookmarks.filter(b => b.id !== id); // keep everything except the one matching id
  renderBookmarks(); // refresh the UI
}


Filters out the bookmark whose id matches.

Calls renderBookmarks() to update the list you see.

Small improvements (optional but recommended)

Use one ID strategy
Either keep Date.now() or switch to your helper:

// If you want to use the helper:
const bookmark = { id: generateBookId(), title, url, category };


Basic validation (avoid empty values, ensure URL has a protocol)

if (!title.trim() || !url.trim()) return alert("Please enter both title and URL.");
if (!/^https?:\/\//i.test(url)) url = "https://" + url;


Avoid injecting user input with innerHTML (safer rendering)

const bookmarkItem = document.createElement('div');
bookmarkItem.className = 'bookmark-item';

const info = document.createElement('div');
info.className = 'bookmark-info';

const h3 = document.createElement('h3');
h3.textContent = b.title;

const a = document.createElement('a');
a.className = 'bookmark-link';
a.href = b.url;
a.target = '_blank';
a.textContent = b.url;

const cat = document.createElement('div');
cat.className = 'bookmark-category';
cat.textContent = b.category;

const del = document.createElement('button');
del.className = 'delete-btn';
del.textContent = 'Delete';
del.addEventListener('click', () => handleDelete(b.id));

info.append(h3, a, cat);
bookmarkItem.append(info, del);
bookmarksList.append(bookmarkItem);


Persist to localStorage (so data survives page reloads)

// After push/delete:
localStorage.setItem('bookmarks', JSON.stringify(bookmarks));

// On page load:
bookmarks = JSON.parse(localStorage.getItem('bookmarks') || '[]');
renderBookmarks();


If you want, I can fold these improvements into a single polished version of your code with comments.
