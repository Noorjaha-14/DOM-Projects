Main Program
â”‚
â”œâ”€â”€ Variables & Elements
â”‚   â”œâ”€â”€ generateTaskId() â†’ // Generates a random 4-digit number for each task ID
â”‚   â”œâ”€â”€ addButton = #add-button // "Add" button element
â”‚   â”œâ”€â”€ inputField = #input-field // Text input for entering task
â”‚   â”œâ”€â”€ taskList = #task-list // <ul> or <ol> where tasks will appear
â”‚   â”œâ”€â”€ tasks = [] // Array storing all tasks (objects)
â”‚   â”œâ”€â”€ filterButtons = .filter-btn // Buttons for filtering tasks
â”‚   â”œâ”€â”€ currentFilter = "All" // Default filter is "All"
â”‚   â”œâ”€â”€ filteredTasks = [] // Tasks after applying current filter
â”‚
â”œâ”€â”€ Event Listeners
â”‚   â”œâ”€â”€ addButton.click
â”‚   â”‚   â”œâ”€â”€ Get text from input
â”‚   â”‚   â”œâ”€â”€ If empty â†’ alert user ("Please enter a task!")
â”‚   â”‚   â”œâ”€â”€ Else:
â”‚   â”‚   â”‚   â”œâ”€â”€ addTask(taskText) // Create and store task
â”‚   â”‚   â”‚   â”œâ”€â”€ applyFilter() // Refresh task display
â”‚   â”‚   â”‚   â””â”€â”€ Clear input field
â”‚   â”‚
â”‚   â”œâ”€â”€ filterButtons.click
â”‚   â”‚   â”œâ”€â”€ Remove 'active' class from all filter buttons
â”‚   â”‚   â”œâ”€â”€ Add 'active' class to clicked button
â”‚   â”‚   â”œâ”€â”€ Set currentFilter based on button's "data-filter" attribute
â”‚   â”‚   â””â”€â”€ applyFilter() // Show tasks for selected filter
â”‚   â”‚
â”‚   â”œâ”€â”€ inputField.keypress (Enter)
â”‚   â”‚   â”œâ”€â”€ Same logic as addButton click â†’ allows adding task by pressing Enter
â”‚   â”‚
â”‚   â”œâ”€â”€ clearCompletedButton.click
â”‚   â”‚   â”œâ”€â”€ Remove all completed tasks from tasks[]
â”‚   â”‚   â””â”€â”€ applyFilter() // Update displayed list
â”‚   â”‚
â”‚   â””â”€â”€ DOMContentLoaded
â”‚       â”œâ”€â”€ applyFilter() // Initial display of tasks
â”‚       â””â”€â”€ updateItemsLeft() // Show how many tasks are pending
â”‚
â”œâ”€â”€ Functions
â”‚   â”œâ”€â”€ applyFilter()
â”‚   â”‚   â”œâ”€â”€ If "All" â†’ filteredTasks = tasks
â”‚   â”‚   â”œâ”€â”€ If "Active" â†’ filteredTasks = tasks where completed == false
â”‚   â”‚   â”œâ”€â”€ If "Completed" â†’ filteredTasks = tasks where completed == true
â”‚   â”‚   â””â”€â”€ showTasks() // Refresh the task list UI
â”‚   â”‚
â”‚   â”œâ”€â”€ addTask(userInput)
â”‚   â”‚   â”œâ”€â”€ Create task object:
â”‚   â”‚   â”‚   â”œâ”€â”€ id = generateTaskId()
â”‚   â”‚   â”‚   â”œâ”€â”€ text = userInput
â”‚   â”‚   â”‚   â””â”€â”€ completed = false
â”‚   â”‚   â””â”€â”€ Push into tasks[] array
â”‚   â”‚
â”‚   â”œâ”€â”€ showTasks()
â”‚   â”‚   â”œâ”€â”€ Clear current task list display
â”‚   â”‚   â”œâ”€â”€ If no tasks in list:
â”‚   â”‚   â”‚   â”œâ”€â”€ Show "Your to-do list is empty" if total tasks == 0
â”‚   â”‚   â”‚   â””â”€â”€ Show "No tasks found for this filter" if tasks exist but filter has no match
â”‚   â”‚   â”œâ”€â”€ Else for each task in filteredTasks:
â”‚   â”‚   â”‚   â”œâ”€â”€ Create <li> container
â”‚   â”‚   â”‚   â”œâ”€â”€ Create checkbox â†’ sets completed state
â”‚   â”‚   â”‚   â”œâ”€â”€ Create span â†’ displays task text
â”‚   â”‚   â”‚   â”œâ”€â”€ Add "Completed" CSS class if task is done
â”‚   â”‚   â”‚   â”œâ”€â”€ Create delete icon
â”‚   â”‚   â”‚   â”œâ”€â”€ Append checkbox, text, and delete icon to li
â”‚   â”‚   â”‚   â””â”€â”€ Append li to task list in DOM
â”‚   â”‚   â””â”€â”€ updateItemsLeft() // Update remaining tasks count
â”‚   â”‚
â”‚   â”œâ”€â”€ handleToggle(id)
â”‚   â”‚   â”œâ”€â”€ Flip the completed value of the task with matching id
â”‚   â”‚   â””â”€â”€ applyFilter() // Refresh UI
â”‚   â”‚
â”‚   â”œâ”€â”€ deleteTask(id)
â”‚   â”‚   â”œâ”€â”€ Remove task from tasks[] by ID
â”‚   â”‚   â””â”€â”€ applyFilter()
â”‚   â”‚
â”‚   â””â”€â”€ updateItemsLeft()
â”‚       â”œâ”€â”€ Count tasks where completed == false
â”‚       â””â”€â”€ Show number in footer span

What this app does

A simple to-do list where you can:

Add tasks (by clicking Add or pressing Enter)

Filter by All / Active / Completed

Toggle a taskâ€™s complete state

Delete individual tasks

Clear all completed tasks

See how many items are left

1) Utilities & State
generateTaskId()
function generateTaskId() {
  return Math.floor(1000 + Math.random() * 9000);
}


Returns an integer in the range 1000â€“9999.

Used as a taskâ€™s unique id (random; collisions are unlikely but possible in theory).

DOM references & app state
const addButton = document.getElementById('add-button');
const inputField = document.getElementById('input-field');
let taskList = document.getElementById("task-list");
let tasks = [];
const filterButtons = document.querySelectorAll(".filter-btn");
let currentFilter = "All";
let filteredTasks = [];


tasks: the full list of tasks.

filteredTasks: whatâ€™s currently shown (depends on the active filter).

currentFilter: one of "All" | "Active" | "Completed".

2) Adding tasks
Add via button click
addButton.addEventListener("click", () => {
  let taskText = inputField.value.trim();
  
  //.trim()

.trim() is a built-in JavaScript string method.

It removes all leading and trailing whitespace (spaces, tabs, newlines) from the string.

Example:

" Hello ".trim() â†’ "Hello".

" ".trim() â†’ "" (empty string).

let taskText = ...;

Stores the cleaned-up input (without extra spaces at the start or end) into a variable named taskText.

âœ… Why use it?
When building apps like a to-do list, users might accidentally add spaces before/after their task names. Using .trim() ensures you store only the meaningful text.

ğŸ‘‰ Without .trim(): " Buy milk " gets stored with spaces.
ğŸ‘‰ With .trim(): "Buy milk" is stored cleanly.

  if (taskText === "") { alert("Please enter a task!"); return; }
  addTask(taskText);
  applyFilter();
  inputField.value = '';
});


Reads & trims text.

Blocks empty input.

Calls addTask to push a new task into tasks.

Calls applyFilter() to refresh the view.

Clears the input.

Add via Enter key
inputField.addEventListener("keypress", (e) => {
  if (e.key === "Enter") {
    // same logic as click handler
  }
});


Same flow as the button.

addTask()
function addTask(userInput) {
  const newTask = { id: generateTaskId(), text: userInput, completed: false };
  tasks.push(newTask);
}


Creates a new task object and appends it to tasks.

3) Filtering
Filter button setup
filterButtons.forEach((btn) => {
  btn.addEventListener("click", () => {
    filterButtons.forEach((b) => b.classList.remove("active"));
    btn.classList.add("active");
    currentFilter = btn.getAttribute('data-filter'); // "All" | "Active" | "Completed"
    applyFilter();
  });
});


Visually marks the current filter button as active.

Updates currentFilter and re-renders.

applyFilter()
function applyFilter() {
  if (currentFilter === "All") {
    filteredTasks = tasks;
  } else if (currentFilter === "Active") {
    filteredTasks = tasks.filter(task => !task.completed);
  } else {
    filteredTasks = tasks.filter(task => task.completed);
  }
  showTasks();
}


Decides what filteredTasks should be.

Calls showTasks() to rebuild the list.

Note: For "All", it sets filteredTasks = tasks (same array reference). Thatâ€™s fine because you always call applyFilter() after any change.

4) Rendering the list
showTasks()
function showTasks() {
  taskList.innerHTML = "";

  if (filteredTasks.length === 0 && tasks.length === 0) {
    taskList.innerHTML = '<li class="empty-message">Your to-do list is empty</li>';
    return;
  } else if (filteredTasks.length === 0 && tasks.length > 0) {
    taskList.innerHTML = '<li class="empty-message">No tasks found for this filter.</li>';
    return;
  }

  filteredTasks.forEach((task) => {
    let li = document.createElement("li");
    li.setAttribute("data-id", task.id);

    const checkbox = document.createElement('input');
    const span = document.createElement('span');
    const deleteBtn = document.createElement('i');

    // checkbox
    checkbox.type = 'checkbox';
    checkbox.checked = task.completed;
    checkbox.addEventListener("change", () => {
      handleToggle(task.id);
    });

    // text
    span.innerText = task.text;
    if (task.completed) {
      span.classList.add('Completed'); // assumes your CSS uses this class
    }

    // delete button
    deleteBtn.classList.add('fas', 'fa-trash');
    deleteBtn.addEventListener("click", () => {
      deleteTask(task.id);
    });

    li.append(checkbox, span, deleteBtn);
    taskList.append(li);
  });

  updateItemsLeft();
}


Clears the list container.

Shows a helpful empty message if needed.

Builds each <li> with:

A checkbox (toggles completed)

A <span> for the text (+ a CSS class if completed)

A trash icon to delete

Hooks listeners for toggle and delete.

Updates the â€œitems leftâ€ counter at the end.

5) Updating task state
Toggle complete
function handleToggle(id) {
  tasks = tasks.map((task) => {
    if (task.id === id) {
      return { ...task, completed: !task.completed };
    } else {
      return task;
    }
  });
  applyFilter();
}


Replaces tasks with a new array, flipping completed for the matching id.

Reapplies the filter to refresh the view.

Delete a task
function deleteTask(id) {
  tasks = tasks.filter(task => task.id !== id);
  applyFilter();
}


Removes the matching task and re-renders.

Clear completed
const clearCompletedButton = document.querySelector(".list-footer button");
clearCompletedButton.addEventListener("click", () => {
  tasks = tasks.filter(task => !task.completed);
  applyFilter();
});


Keeps only active tasks and refreshes.

6) Items left footer
function updateItemsLeft() {
  const itemsLeftSpan = document.querySelector(".list-footer span");
  const activeTasks = tasks.filter(task => !task.completed).length;
  itemsLeftSpan.textContent = `${activeTasks} items left`;
}


Counts incomplete tasks and updates the footer text.

7) Initial load
document.addEventListener("DOMContentLoaded", () => {
  applyFilter();
  updateItemsLeft();
});


When the page is ready, renders the current (empty) state and shows â€œ0 items leftâ€.

Typical user flow (quick mental model)

Page loads â†’ applyFilter() â†’ shows â€œYour to-do list is emptyâ€.

You type a task and press Enter (or click Add) â†’ addTask() pushes it â†’ applyFilter() â†’ showTasks() rebuilds â†’ footer updates.

Toggle a checkbox â†’ handleToggle() updates tasks â†’ applyFilter() â†’ UI re-renders.

Click Completed filter â†’ applyFilter() sets filteredTasks accordingly â†’ re-renders.

Click trash icon â†’ deleteTask() â†’ applyFilter() â†’ re-render.

Click Clear Completed â†’ removes all completed â†’ re-render.

Small notes & easy improvements (optional)

Class name casing: You add 'Completed' (capital C). Make sure your CSS matches exactly, or consider 'completed' for consistency.

ID collisions: Rare, but possible. If you want to be safe, regenerate while an id exists in tasks.

Persistence: Save/load tasks to localStorage so the list survives refreshes.

Accessibility: Use a <button> for delete with aria-label="Delete task" instead of relying on an <i> alone; associate labels with checkboxes.

Performance: For very large lists, consider event delegation instead of attaching listeners per item.

If you want, I can add localStorage in-place and show exactly where to put it.
â”‚
â””â”€â”€ End


// âœ… Utility: Generate Unique ID
function generateTaskId() {
    return Math.floor(1000 + Math.random() * 9000);
}

// âœ… Step 2: Store tasks in an array
let tasks = [];
let filteredTasks = [];
let currentFilter = "All";

// âœ… Step 1: Access DOM Elements
const addButton = document.getElementById('add-button');
const inputField = document.getElementById('input-field');
let taskList = document.getElementById("task-list");
const filterButtons = document.querySelectorAll(".filter-btn");
const clearCompletedButton = document.querySelector(".list-footer button");
const itemsLeftSpan = document.querySelector(".list-footer span");

// ================== EVENT LISTENERS ==================

// âœ… Step 3: Add task when button is clicked
addButton.addEventListener("click", () => {
    let taskText = inputField.value.trim();
    if (taskText === "") {
        alert("Please enter a task!");
        return;
    }
    addTask(taskText);
    applyFilter();
    inputField.value = ''; // âœ… Step 5: Clear input field
});

// âœ… Step 4: Add task when Enter key is pressed
inputField.addEventListener("keypress", (e) => {
    if (e.key === "Enter") {
        let taskText = inputField.value.trim();
        if (taskText === "") {
            alert("Please enter a task!");
            return;
        }
        addTask(taskText);
        applyFilter();
        inputField.value = ''; // âœ… Step 5: Clear input field
    }
});

// âœ… Step 7: Highlight clicked filter button & filter tasks
filterButtons.forEach((btn) => {
    btn.addEventListener("click", () => {
        filterButtons.forEach((b) => b.classList.remove("active"));
        btn.classList.add("active");
        currentFilter = btn.getAttribute('data-filter');
        applyFilter();
    });
});

// âœ… Step 10: Clear Completed button functionality
clearCompletedButton.addEventListener("click", () => {
    tasks = tasks.filter(task => !task.completed);
    applyFilter();
});

// âœ… Step 3 (Empty list message) - Run on DOMContentLoaded
document.addEventListener("DOMContentLoaded", () => {
    applyFilter();
    updateItemsLeft();
});

// ================== FUNCTIONS ==================

// âœ… Step 6: Add Task Function
function addTask(userInput) {
    const newTask = {
        id: generateTaskId(),
        text: userInput,
        completed: false // default
    };
    tasks.push(newTask);
}

// âœ… Step 8: Apply Filters
function applyFilter() {
    if (currentFilter === "All") {
        filteredTasks = tasks;
    } else if (currentFilter === "Active") {
        filteredTasks = tasks.filter(task => !task.completed);
    } else {
        filteredTasks = tasks.filter(task => task.completed);
    }
    showTasks();
}

// âœ… Step 1, 6, 8: Render tasks (with empty list handling)
function showTasks() {
    taskList.innerHTML = "";

    if (filteredTasks.length === 0 && tasks.length === 0) {
        taskList.innerHTML = '<li class="empty-message">Your to-do list is empty</li>';
        return;
    } else if (filteredTasks.length === 0 && tasks.length > 0) {
        taskList.innerHTML = '<li class="empty-message">No tasks found for this filter.</li>';
        return;
    }

    filteredTasks.forEach((task) => {
        let li = document.createElement("li");
        li.setAttribute("data-id", task.id);

        const checkbox = document.createElement('input');
        const span = document.createElement('span');
        const deleteBtn = document.createElement('i');

        // checkbox
        checkbox.type = 'checkbox';
        checkbox.checked = task.completed;
        checkbox.addEventListener("change", () => {
            handleToggle(task.id);
        });

        // span (task text)
        span.innerText = task.text; //task.text holds the userâ€™s input (e.g., "Buy milk").
        if (task.completed) {
            span.classList.add('completed'); // âœ… strike-through class
        }

        // delete button
        deleteBtn.classList.add('fas', 'fa-trash');
        deleteBtn.addEventListener("click", () => {
            deleteTask(task.id);
        });

        // append elements to li
        li.append(checkbox);
        li.append(span);
        li.append(deleteBtn);
        taskList.append(li);
    });

    updateItemsLeft(); // âœ… Step 9
}

// âœ… Step 6: Toggle completion
function handleToggle(id) {
    tasks = tasks.map((task) =>
        task.id === id ? { ...task, completed: !task.completed } : task
    );
    applyFilter();
}

// âœ… Delete task
function deleteTask(id) {
    tasks = tasks.filter(task => task.id !== id);
    applyFilter();
}

// âœ… Step 9: Update Active Task Counter
function updateItemsLeft() {
    const activeTasks = tasks.filter(task => !task.completed).length;
    itemsLeftSpan.textContent = `${activeTasks} items left`;
}

